import hashlib
import progressbar

# this is just a const of the number dict file:
numberDict = {
    0: "0110000",
    1: "0110001",
    2: "0110010",
    3: "0110011",
    4: "0110100",
    5: "0110101",
    6: "0110110",
    7: "0110111",
    8: "0111000",
    9: "0111001"
}

# this is just the xor function of the original program
def xor(a, b):
    # perform the bitwise x-or on the a and b binary string inputted
    ans = ""
    # Loop to iterate over the
    # Binary Strings
    for i in range(len(a)):
    # If the Character matches
        if (str(a[i]) == str(b[i])):
            ans += "0"
        else:
            ans += "1"
    return ans
    
# this is the isInt function of the original program
def isInt(s):
    # check if an inputted character is type = string
    try:
        int(s)
        return True
    except ValueError:
        return False
    
# this is the string to binary function of the original program
def fnStrToBin(StringToBin):
    # translate a string into a binary string
    arrCharsBin = []
    for char in [char for char in StringToBin]:
        if isInt(char):
            add = numberDict[int(char)].zfill(8)
            arrCharsBin.append(f"{add}")
        else:
            add = bin(ord(char)).replace('0b', '').zfill(8)
            arrCharsBin.append(f"{add}")
    returnStr = ''
    for charBin in arrCharsBin:
        returnStr += charBin
    return returnStr

# this is the encryption function of the original program
def fnEncryptString(strPassword, strKey):
    # Password String to binary string
    strBinaryPW = fnStrToBin(strPassword)

    # Key string to binary string
    strBinaryKey = fnStrToBin(strKey)
    # repeat key until every bit from pw can be xor'ed with the key
    try:
        strBinaryKey = (
            strBinaryKey * (int(len(strBinaryPW)/len(strBinaryKey))+1))[:len(strBinaryPW)]
    except ZeroDivisionError:
        # happens if no key give
        exit()
    # Perform the binary xor operation
    strXor = xor(strBinaryPW, strBinaryKey)

    # Create the cipher text with the result of the binary xor
    strCipherText = ''
    for strcharcipherText in range(0, len(strXor), 8):
        strCipherText += str(
            int(strXor[strcharcipherText: strcharcipherText + 8], 2)).zfill(3)
    # return the cipher text
    return strCipherText


# so the key is encrypted with it's own hash, so you can just brute force the key by using a random key, hash it and encrypt it with itself
originalPasswordHash = '048082066071115093077050003021021047081029055093023016126001024100093068017045001028102087075067121081024048093064071040081074109083070018114092075050085023016121085074103004065065121087028048'
password_list = '/usr/share/wordlists/rockyou.txt'

# get the number of lines in the file:
with open(password_list, 'r', encoding='latin-1') as password_file:
    number_of_lines = len(password_file.readlines())

print(f"The password file contains {number_of_lines} passwords")

# start the progressbar
bar = progressbar.ProgressBar(maxval=number_of_lines, \
    widgets=[progressbar.Bar('=', '[', ']'), ' ', progressbar.Percentage()])
bar.start()

try:
    # Tried latin because of the encoding error
    with open(password_list, 'r', encoding='latin-1') as file:
        for count,line in enumerate(file):
            newKey = line
            strKeyHash = hashlib.sha256(newKey.encode()).hexdigest()
            strEncryptedHash = fnEncryptString(strKeyHash, newKey)
            #print(f"Count = {count}, PW = {line}")
            bar.update(count + 1)
            #print(f"Comparing {strEncryptedHash} with {originalPasswordHash}")
            if strEncryptedHash == originalPasswordHash:
                print(f"This is the original password {line}, it took {count} tries")
                bar.finish()
                break
    file.close()
except UnicodeDecodeError as e:
    print(f"UnicodeDecodeError, Count is {count}")
    print(e)
    file.close()
    bar.finish()
    
    #! program can only handle up to line 600k, there is an error, takes about 2min to reach that point.

print("The program finished")